<h1 align="center" style="font-size: 44px"> 实验五：用户进程管理 </h1>

**小组成员：**

- 管一凡：2312307
- 周雨晴：2312313
- 欧一凡：2312826

**Github仓库地址：**https://github.com/Yifan-Guan/NKU_OS_2025_lab4.git

**说明：**

# 练习1: 加载应用程序并执行

### 说明load_icode函数中相应的设计实现过程。

**设置用户栈指针 (tf->gpr.sp)** 设置为 `USTACKTOP`，即用户栈的顶部地址 确保用户程序有正确的栈空间用于函数调用和局部变量存储

**设置程序计数器 (tf->epc)** 设置为 `elf->e_entry`，即 ELF 文件的入口地址 这是用户程序的第一条指令地址，进程恢复执行时将从此处开始

**设置状态寄存器 (tf->status)** `(sstatus | SSTATUS_SPIE) & ~SSTATUS_SPP`的含义： **清除 SPP 位**：SPP=0 表示从用户模式(User Mode)进入异常，sret 时将返回用户模式 **设置 SPIE 位**：SPIE=1 表示在用户模式下启用中断 保留原有的 sstatus 寄存器其他位设置

### 请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

### 阶段1：进程创建和初始化

1. **进程创建** - `do_fork()`创建新进程 分配进程控制块 `alloc_proc()` 设置内核栈 `setup_kstack()` 复制内存空间 `copy_mm()` 设置执行上下文 `copy_thread()`
2. **加载可执行文件** - `do_execve()`→ `load_icode()` 解析 ELF 文件格式 建立用户内存空间（代码段、数据段、BSS段） 设置用户栈空间，配置陷阱帧(trapframe)用于返回到用户态

### 阶段2：进程调度执行

1. **进程变为RUNNABLE** - `wakeup_proc()` 进程状态设置为 `PROC_RUNNABLE` 加入调度队列等待CPU分配
2. **进程调度** - `schedule()`→ `proc_run()` 调度器选择该进程执行 切换页表：`lsatp(next->pgdir)`加载用户页表 上下文切换：`switch_to(&(prev->context), &(next->context))`

### 阶段3：从内核态返回到用户态

1. **上下文切换后的执行流程**： `// switch_to 返回后，执行流程进入新进程的上下文 forkret() → forkrets() → __trapret`
2. **陷阱返回** - `__trapret`(在 trapentry.S 中) 从陷阱帧恢复所有通用寄存器 执行 `sret`指令：这是关键转折点 `sret`会根据陷阱帧中的 status 寄存器设置： 将模式从S-mode切换到U-mode 将程序计数器设置为epc的值 根据SPIE位设置中断使能状态

### 阶段4：用户程序开始执行

1. **执行第一条用户指令** CPU 从 `elf->e_entry`地址开始执行 运行在用户模式(U-mode)下 使用用户栈 `USTACKTOP` 用户态进程正式开始运行

# 练习2: 父进程复制自己的内存空间给子进程（需要编码）

创建子进程的函数`do_fork`在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过`copy_range`函数（位于kern/mm/pmm.c中）实现的，请补充`copy_range`的实现，确保能够正确执行。

请在实验报告中简要说明你的设计实现过程。

# 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现

## 一、函数执行流程分析

### 1. fork() 函数

**用户态操作：**

- 用户程序调用 fork() 系统调用
- 准备系统调用参数（clone_flags等）

**内核态操作（do_fork）：**

```
1. alloc_proc()      // 分配进程控制块
2. setup_kstack()   // 分配内核栈
3. copy_mm()        // 复制内存空间
4. copy_thread()    // 设置陷阱帧和上下文
5. get_pid()        // 分配PID
6. wakeup_proc()    // 唤醒子进程
```

**返回用户态：**

- 父进程返回子进程PID
- 子进程返回0

### 2. exec() 函数

**用户态操作：**

- 用户程序调用 execve() 系统调用
- 传递程序路径和参数

**内核态操作（do_execve）：**

```
1. 检查参数合法性
2. 清空原进程内存空间（exit_mmap, put_pgdir, mm_destroy）
3. load_icode() 加载新程序：
   - 解析ELF格式
   - 建立新的内存映射
   - 设置用户栈
   - 配置陷阱帧（LAB5部分）
```

**返回用户态：**

- 不返回到原调用点，直接跳转到新程序入口

### 3. wait() 函数

**用户态操作：**

- 父进程调用 wait() 等待子进程退出

**内核态操作（do_wait）：**

```
1. 查找指定PID或任意子进程
2. 如果子进程是ZOMBIE状态：
   - 回收资源（unhash_proc, remove_links）
   - 释放内核栈和进程控制块
3. 如果子进程未退出：
   - 设置父进程为SLEEPING状态
   - 调用schedule()让出CPU
```

**返回用户态：**

- 返回子进程退出码或错误码

### 4. exit() 函数

**用户态操作：**

- 用户程序调用 exit() 系统调用

**内核态操作（do_exit）：**

```
1. 释放内存资源（exit_mmap等）
2. 设置进程状态为ZOMBIE
3. 唤醒等待的父进程
4. 将子进程过继给init进程
5. 调用schedule()切换进程
```

**返回用户态：**

- 不返回，进程终止

## 二、用户态与内核态交错执行分析

### 执行模式切换模式：

```
用户程序 → 系统调用 → 内核处理 → 返回用户程序
User Mode → Trap → Kernel Mode → sret → User Mode
```

### 具体交错执行流程：

1. **系统调用入口**： `用户态: mov a7, SYS_xxx    // 准备系统调用号 用户态: ecall              // 陷入内核态 内核态: __alltraps         // 保存上下文，进入内核`
2. **内核处理**： 根据系统调用号分发到相应处理函数 执行具体的内核操作（进程管理、内存管理等）
3. **返回用户态**： `内核态: 设置陷阱帧返回值(a0寄存器) 内核态: __trapret          // 恢复上下文 内核态: sret               // 返回到用户态 用户态: 继续执行系统调用后的指令`

### 内核态结果返回机制：

1. **通过陷阱帧的a0寄存器**：内核将返回值设置到陷阱帧的a0寄存器
2. **上下文恢复**：`__trapret`会恢复所有寄存器包括a0
3. **用户态获取结果**：用户程序从系统调用返回值中获取结果

## 三、用户态进程执行状态生命周期图

```
┌─────────────────┐    alloc_proc()     ┌─────────────┐
│   PROC_UNINIT    │ ──────────────────►│ PROC_RUNNING│ ◄──┐
│   (未初始化)     │                    │  (运行中)   │    │
└─────────────────┘                    └─────────────┘    │
         │                                              schedule()
         │                      wakeup_proc()             │
         │                    ┌───────────────────────────┘
         │                    │                           │
         │                    ▼                           │
         │    do_fork()   ┌─────────────┐  need_resched=1 │
         └───────────────►│ PROC_READY  │ ◄───────────────┘
                          │  (就绪)     │
                          └─────────────┘
                                  │    schedule()选择
                                  │
                                  ▼
                          ┌─────────────┐    do_exit()    ┌─────────────┐
                          │PROC_SLEEPING│ ───────────────►│ PROC_ZOMBIE │
                          │  (睡眠)     │                 │  (僵尸)     │
                          └─────────────┘                 └─────────────┘
                                  │                             │
                                  │ wakeup_proc()               │ do_wait()回收
                                  │                             │
                      ┌───────────┴───────────┐                 │
                      │                       │                 │
                      ▼                       ▼                 ▼
               ┌─────────────┐       ┌─────────────┐      进程资源完全释放
               │ PROC_READY   │       │ PROC_RUNNING│
               │    (就绪)    │       │   (运行中)   │
               └─────────────┘       └─────────────┘

状态转换事件说明：
- PROC_UNINIT → PROC_READY:   进程创建完成，加入调度队列
- PROC_READY → PROC_RUNNING:  被调度器选中，获得CPU
- PROC_RUNNING → PROC_READY:   时间片用完或更高优先级进程就绪
- PROC_RUNNING → PROC_SLEEPING: 等待资源（如wait子进程、sleep等）
- PROC_SLEEPING → PROC_READY:   等待的条件满足（子进程退出等）
- PROC_RUNNING → PROC_ZOMBIE:  进程调用exit()自行终止
- PROC_ZOMBIE → 资源释放:      父进程调用wait()回收资源
```

## 四、关键特点总结

1. **权限边界清晰**：用户态负责业务逻辑，内核态负责资源管理和安全控制
2. **通过陷阱机制切换**：ecall/sret 指令实现模式安全切换
3. **上下文完整保存**：陷阱帧确保执行现场不被破坏
4. **返回值通过寄存器传递**：a0寄存器作为系统调用返回值通道
5. **状态机管理**：明确的进程状态转换确保系统稳定性

这种设计保证了操作系统的安全性、隔离性和可靠性，是现代操作系统的基本架构模式。

# Challenge1：实现 Copy on Write （COW）机制

   给出实现源码,测试用例和设计报告（包括在cow情况下的各种状态转换（类似有限状态自动机）的说明）。

# Challenge2: 说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？

### 用户程序被预先加载到内存中的时机

**用户程序是在内核链接阶段被直接嵌入到内核镜像中的**，具体过程如下：

1. **编译阶段**：用户程序（`uprog`）被单独编译成目标文件
2. **链接阶段**：在链接内核时，通过以下命令将用户程序二进制内容嵌入： `$(kernel): $(KOBJS) $(USER_BINS)    $(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS) --format=binary $(USER_BINS) --format=default`
3. **内存加载**：当内核被加载器（QEMU的`-device loader`或SPIKE）载入内存时，用户程序作为内核的一部分被同时加载到内存中

### 与常用操作系统的区别

| 方面         | 该实验系统                 | 常用操作系统（Linux/Windows） |
| ------------ | -------------------------- | ----------------------------- |
| **加载时机** | 编译链接时静态嵌入         | 运行时动态加载                |
| **内存位置** | 与内核在同一地址空间       | 在用户进程的独立地址空间      |
| **加载方式** | 直接作为内核数据段的一部分 | 通过文件系统读取可执行文件    |
| **地址绑定** | 编译时确定绝对地址         | 运行时进行地址重定位          |
| **隔离性**   | 用户程序与内核无隔离       | 有严格的内存保护隔离          |

### 原因分析

这种设计差异的主要原因是：

1. **教学目的**：简化系统复杂度，让学生专注于内核核心机制的理解
2. **环境限制**：在实验环境中尚未实现完整的文件系统和动态加载器
3. **调试方便**：静态嵌入便于调试和跟踪用户程序的执行
4. **启动速度**：避免了运行时文件I/O操作，启动更快

### 实际系统的加载过程

在真实操作系统中，用户程序的加载过程要复杂得多：

- 通过文件系统读取可执行文件
- 进行动态链接和地址重定位
- 建立独立的内存映射和页表
- 设置完整的进程控制块和环境变量

这种实验性的设计虽然简化了实现，但也失去了真实系统中进程隔离、动态加载、按需分页等重要特性。